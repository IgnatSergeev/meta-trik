From 2e3e4a17f690d4bc9f4a8d6f01cc3d30ac659ed3 Mon Sep 17 00:00:00 2001
From: Mikhail Kshevetskiy <mikhail.kshevetskiy@gmail.com>
Date: Sun, 17 Jun 2012 13:25:51 +0400
Subject: [PATCH 3/3] arm/davinci: add trikboard

---
 arch/arm/mach-davinci/Kconfig                   |    8 +-
 arch/arm/mach-davinci/Makefile                  |    1 +
 arch/arm/mach-davinci/board-omapl138-trik.c     |  826 +++++++++++++++++++++++
 arch/arm/mach-davinci/include/mach/uncompress.h |    1 +
 arch/arm/tools/mach-types                       |    1 +
 sound/soc/davinci/davinci-evm.c                 |   24 +-
 6 files changed, 859 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm/mach-davinci/board-omapl138-trik.c

diff --git a/arch/arm/mach-davinci/Kconfig b/arch/arm/mach-davinci/Kconfig
index 32d837d..5c54af5 100644
--- a/arch/arm/mach-davinci/Kconfig
+++ b/arch/arm/mach-davinci/Kconfig
@@ -194,7 +194,7 @@ endchoice
 
 config DA850_WL12XX
 	bool "AM18x wl1271 daughter board"
-	depends on MACH_DAVINCI_DA850_EVM
+	depends on MACH_DAVINCI_DA850_EVM || MACH_OMAPL138_TRIKBOARD
 	help
 	  The wl1271 daughter card for AM18x EVMs is a combo wireless
 	  connectivity add-on card, based on the LS Research TiWi module with
@@ -234,6 +234,12 @@ config MACH_OMAPL138_HAWKBOARD
 	  Information of this board may be found at
 	  http://www.hawkboard.org/
 
+config MACH_OMAPL138_TRIKBOARD
+	bool "TI AM1808 / OMAPL-138 Trikboard platform"
+	depends on ARCH_DAVINCI_DA850
+	help
+	  Say Y here to select the TI AM1808 / OMAPL-138 Trikboard.
+
 config DAVINCI_MUX
 	bool "DAVINCI multiplexing support"
 	depends on ARCH_DAVINCI
diff --git a/arch/arm/mach-davinci/Makefile b/arch/arm/mach-davinci/Makefile
index 495e313..5326a1a 100644
--- a/arch/arm/mach-davinci/Makefile
+++ b/arch/arm/mach-davinci/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_MACH_DAVINCI_DA850_EVM)	+= board-da850-evm.o
 obj-$(CONFIG_MACH_TNETV107X)		+= board-tnetv107x-evm.o
 obj-$(CONFIG_MACH_MITYOMAPL138)		+= board-mityomapl138.o
 obj-$(CONFIG_MACH_OMAPL138_HAWKBOARD)	+= board-omapl138-hawk.o
+obj-$(CONFIG_MACH_OMAPL138_TRIKBOARD)	+= board-omapl138-trik.o
 
 # Power Management
 obj-$(CONFIG_CPU_FREQ)			+= cpufreq.o
diff --git a/arch/arm/mach-davinci/board-omapl138-trik.c b/arch/arm/mach-davinci/board-omapl138-trik.c
new file mode 100644
index 0000000..8e7e327
--- /dev/null
+++ b/arch/arm/mach-davinci/board-omapl138-trik.c
@@ -0,0 +1,826 @@
+/*
+ * Hawkboard.org based on TI's OMAP-L138 Platform
+ *
+ * Initial code: Syed Mohammed Khasim
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of
+ * any kind, whether express or implied.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/delay.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+#include <mach/cp_intc.h>
+#include <mach/da8xx.h>
+#include <mach/mux.h>
+#include <mach/aemif.h>
+#include <mach/spi.h>
+#include <linux/mma7660fc.h>
+#include <linux/wl12xx.h>
+
+
+
+#define DA850_TRIK_MMCSD_CD_REG		DA850_GPIO4_1
+#define DA850_TRIK_MMCSD_CD_PIN		GPIO_TO_PIN(4, 1)
+#define DA850_TRIK_USB20_OC_REG		DA850_GPIO5_15
+#define DA850_TRIK_USB20_OC_PIN		GPIO_TO_PIN(5, 15)
+#define DA850_TRIK_LCD_BL_REG		DA850_GPIO6_12
+#define DA850_TRIK_LCD_BL_PIN		GPIO_TO_PIN(6, 12)
+#define DA850_TRIK_AUDIO_RESET_REG	DA850_GPIO6_15
+#define DA850_TRIK_AUDIO_RESET_PIN	GPIO_TO_PIN(6, 15)
+#define DA850_TRIK_ACCEL_IRQ_REG	DA850_GPIO0_13
+#define DA850_TRIK_ACCEL_IRQ_PIN	GPIO_TO_PIN(0, 13)
+
+#define DA850_TRIK_WLAN_IRQ_REG		DA850_GPIO5_10
+#define DA850_TRIK_WLAN_IRQ_PIN		GPIO_TO_PIN(5, 10)
+#define DA850_TRIK_WLAN_ENABLE_REG	DA850_GPIO5_11
+#define DA850_TRIK_WLAN_ENABLE_PIN	GPIO_TO_PIN(5, 11)
+#define DA850_TRIK_BT_ENABLE_REG	DA850_GPIO5_12
+#define DA850_TRIK_BT_ENABLE_PIN	GPIO_TO_PIN(5, 12)
+
+
+static struct mma7660fc_pdata board_mma7660fc_pdata;
+
+int __init archos_accel_init(struct mma7660fc_pdata *pdata)
+{
+	int ret;
+
+	ret = davinci_cfg_reg(DA850_TRIK_ACCEL_IRQ_REG);
+	if (ret) {
+		pr_warning("%s: accelerometer enable PinMux setup failed: %d\n",
+			__func__, ret);
+		return -1;
+	}
+
+	ret = gpio_request_one(DA850_TRIK_ACCEL_IRQ_PIN,
+			GPIOF_DIR_IN, "accelerometer enable");
+	if (ret < 0) {
+		pr_err("%s: failed to request GPIO for accelerometer enable "
+		            "indicator: %d\n", __func__, ret);
+		return -1;
+	}
+
+	pdata->irq = gpio_to_irq(DA850_TRIK_ACCEL_IRQ_PIN);
+	return 0;
+}
+
+/*
+ * GPIO Buttons
+ */
+
+#define DA850_KEYS_DEBOUNCE_MS	10
+/*
+ * At 200ms polling interval it is possible to miss an
+ * event by tapping very lightly on the push button but most
+ * pushes do result in an event; longer intervals require the
+ * user to hold the button whereas shorter intervals require
+ * more CPU time for polling.
+ */
+#define DA850_GPIO_KEYS_POLL_MS	200
+
+static const short trik_gpio_keys_pins[] = {
+	DA850_GPIO2_0,  DA850_GPIO3_4,  DA850_GPIO3_12,
+	DA850_GPIO3_13, DA850_GPIO3_14, DA850_GPIO3_15,
+	-1
+};
+
+static struct gpio_keys_button trik_gpio_buttons[] = {
+	{
+		.type		   = EV_KEY,
+		.active_low	   = 1,
+		.wakeup		   = 0,
+		.debounce_interval = DA850_KEYS_DEBOUNCE_MS,
+		.gpio		   = GPIO_TO_PIN(3, 4),
+		.code		   = KEY_F2,
+		.desc		   = "sw2",
+	},
+
+	{
+		.type		   = EV_KEY,
+		.active_low	   = 1,
+		.wakeup		   = 0,
+		.debounce_interval = DA850_KEYS_DEBOUNCE_MS,
+		.gpio		= GPIO_TO_PIN(2, 0),
+		.code		= KEY_F3,
+		.desc		= "sw3",
+		.active_low	= 1,
+	},
+	{
+		.type		   = EV_KEY,
+		.active_low	   = 1,
+		.wakeup		   = 0,
+		.debounce_interval = DA850_KEYS_DEBOUNCE_MS,
+		.gpio		   = GPIO_TO_PIN(3, 14),
+		.code		   = KEY_F4,
+		.desc		   = "sw4",
+		.active_low	   = 1,
+	},
+	{
+		.type		   = EV_KEY,
+		.active_low	   = 1,
+		.wakeup		   = 0,
+		.debounce_interval = DA850_KEYS_DEBOUNCE_MS,
+		.gpio		   = GPIO_TO_PIN(3, 15),
+		.code		   = KEY_F5,
+		.desc		   = "sw5",
+		.active_low	   = 1,
+	},
+	{
+		.type		   = EV_KEY,
+		.active_low	   = 1,
+		.wakeup		   = 0,
+		.debounce_interval = DA850_KEYS_DEBOUNCE_MS,
+		.gpio		   = GPIO_TO_PIN(3, 13),
+		.code		   = KEY_F6,
+		.desc		   = "sw6",
+		.active_low	   = 1,
+	},
+	{
+		.type		   = EV_KEY,
+		.active_low	   = 1,
+		.wakeup		   = 0,
+		.debounce_interval = DA850_KEYS_DEBOUNCE_MS,
+		.gpio		   = GPIO_TO_PIN(3, 12),
+		.code		   = KEY_F7,
+		.desc		   = "sw7",
+		.active_low	   = 1,
+	}
+};
+
+static struct gpio_keys_platform_data trik_gpio_button_data = {
+	.buttons	= trik_gpio_buttons,
+	.nbuttons	= ARRAY_SIZE(trik_gpio_buttons),
+	.poll_interval	= DA850_GPIO_KEYS_POLL_MS,
+};
+
+static struct platform_device trik_gpio_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &trik_gpio_button_data,
+	}
+};
+
+static void __init trik_gpio_add_device_buttons(void)
+{
+	int ret;
+
+	ret = davinci_cfg_reg_list(trik_gpio_keys_pins);
+	if (ret) {
+		pr_warning("da850trik_init: gpio buttons setup failed: %d\n",
+				ret);
+		return;
+	}
+	platform_device_register(&trik_gpio_button_device);
+}
+
+/* davinci da850 evm audio machine driver */
+static u8 da850_iis_serializer_direction[] = {
+	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
+	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	TX_MODE,
+	INACTIVE_MODE,	RX_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
+	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
+};
+
+static struct snd_platform_data da850_trik_snd_data = {
+	.tx_dma_offset	= 0x2000,
+	.rx_dma_offset	= 0x2000,
+	.op_mode	= DAVINCI_MCASP_IIS_MODE,
+	.num_serializer	= ARRAY_SIZE(da850_iis_serializer_direction),
+	.tdm_slots	= 2,
+	.serial_dir	= da850_iis_serializer_direction,
+	.asp_chan_q	= EVENTQ_0,
+	.version	= MCASP_VERSION_2,
+	.txnumevt	= 1,
+	.rxnumevt	= 1,
+};
+
+static const short da850_trik_mcasp_pins[] __initconst = {
+	DA850_AHCLKX, DA850_ACLKX, DA850_AFSX,
+	DA850_AXR_7 /* TX */, DA850_AXR_9 /* RX */,
+	DA850_GPIO6_15 /* reset */,
+	-1
+};
+
+enum {TRIK_SPI_FLASH, TRIK_SPI_WLAN};
+
+static struct mtd_partition da850trik_spiflash_part[] = {
+	[0] = {
+		.name = "U-Boot",
+		.offset = 0,
+		.size = SZ_256K,
+		.mask_flags = MTD_WRITEABLE,
+	},
+	[1] = {
+		.name = "U-Boot-Env1",
+		.offset = MTDPART_OFS_APPEND,
+		.size = SZ_64K,
+		.mask_flags = MTD_WRITEABLE,
+	},
+	[2] = {
+		.name = "U-Boot-Env2",
+		.offset = MTDPART_OFS_APPEND,
+		.size = SZ_64K,
+		.mask_flags = MTD_WRITEABLE,
+	},
+};
+
+static struct flash_platform_data da850trik_spiflash_data = {
+	.name		= "m25p80",
+	.parts		= da850trik_spiflash_part,
+	.nr_parts	= ARRAY_SIZE(da850trik_spiflash_part),
+	.type		= "m25p128",
+};
+
+static struct davinci_spi_config da850trik_spiflash_cfg = {
+	.io_type	= SPI_IO_TYPE_DMA,
+	.c2tdelay	= 8,
+	.t2cdelay	= 8,
+};
+
+static void trik_wl1271_set_power(bool power_on)
+{
+	static bool power_state;
+
+	pr_debug("Powering %s wl12xx", power_on ? "on" : "off");
+
+	if (power_on == power_state)
+		return;
+	power_state = power_on;
+
+	if (power_on) {
+		/* Power up sequence required for wl127x devices */
+		gpio_set_value(DA850_TRIK_WLAN_ENABLE_PIN, 1);
+		usleep_range(15000, 15000);
+		gpio_set_value(DA850_TRIK_WLAN_ENABLE_PIN, 0);
+		usleep_range(1000, 1000);
+		gpio_set_value(DA850_TRIK_WLAN_ENABLE_PIN, 1);
+		msleep(70);
+	} else {
+		gpio_set_value(DA850_TRIK_WLAN_ENABLE_PIN, 0);
+	}
+}
+
+static struct wl12xx_platform_data da850trik_wlan_data __initdata = {
+	.irq			= -1,
+	.set_power		= trik_wl1271_set_power,
+	.board_ref_clock	= WL12XX_REFCLOCK_38,
+	.platform_quirks	= WL12XX_PLATFORM_QUIRK_EDGE_IRQ,
+};
+
+static struct davinci_spi_config da850trik_wlan_cfg = {
+	.io_type	= SPI_IO_TYPE_DMA,
+	.c2tdelay	= 8,
+	.t2cdelay	= 8,
+};
+
+static struct spi_board_info da850trik_spi_info[] = {
+	[TRIK_SPI_FLASH] = {
+		.modalias		= "m25p80",
+		.controller_data	= &da850trik_spiflash_cfg,
+		.platform_data		= &da850trik_spiflash_data,
+		.mode			= SPI_MODE_0,
+		.max_speed_hz		= 30000000,
+		.bus_num		= 0,
+		.chip_select		= 0,
+	},
+	[TRIK_SPI_WLAN] = {
+		.modalias		= "wl1271_spi",
+		.controller_data	= &da850trik_wlan_cfg,
+		.platform_data		= &da850trik_wlan_data,
+		.mode			= SPI_MODE_0,
+		.max_speed_hz   	= 48000000,
+		.bus_num		= 0,
+		.chip_select		= 1,
+	},
+};
+
+static const short da850_trik_wl1271_pins[] __initconst = {
+	DA850_TRIK_WLAN_IRQ_REG,
+	DA850_TRIK_WLAN_ENABLE_REG,
+	DA850_TRIK_BT_ENABLE_REG,
+	-1
+};
+
+static struct gpio trik_wl1271_gpios[] __initdata = {
+	{ DA850_TRIK_WLAN_ENABLE_PIN, GPIOF_OUT_INIT_LOW, "wlan power"      },
+	{ DA850_TRIK_WLAN_IRQ_PIN,    GPIOF_IN,		  "wlan irq"        },
+	{ DA850_TRIK_BT_ENABLE_PIN,   GPIOF_OUT_INIT_LOW, "bluetooth power" },
+};
+
+static void __init trik_init_wl1271(void)
+{
+	int irq, ret;
+
+	ret = davinci_cfg_reg_list(da850_trik_wl1271_pins);
+	if (ret) {
+		pr_warning("%s: WLAN/BT mux setup failed: %d\n",
+			__func__, ret);
+		goto error;
+	}
+
+	ret = gpio_request_array(trik_wl1271_gpios,
+				 ARRAY_SIZE(trik_wl1271_gpios));
+	if (ret < 0)
+		goto error;
+
+	irq = gpio_to_irq(DA850_TRIK_WLAN_IRQ_PIN);
+	if (irq < 0)
+		goto err_irq;
+
+	da850trik_wlan_data.irq = irq;
+
+/*
+	ret = wl12xx_set_platform_data(&da850trik_wlan_data);
+	if (ret) {
+		pr_err("Could not set wl12xx data: %d\n", ret);
+		goto err_irq;
+	}
+*/
+	return;
+
+err_irq:
+	gpio_free(DA850_TRIK_WLAN_ENABLE_PIN);
+	gpio_free(DA850_TRIK_WLAN_IRQ_PIN);
+	gpio_free(DA850_TRIK_BT_ENABLE_PIN);
+error:
+	printk(KERN_ERR "wl1271 board initialisation failed\n");
+}
+
+static struct davinci_pm_config da850_pm_pdata = {
+	.sleepcount = 128,
+};
+
+static struct platform_device da850_pm_device = {
+	.name           = "pm-davinci",
+	.dev = {
+		.platform_data	= &da850_pm_pdata,
+	},
+	.id             = -1,
+};
+
+
+/*
+ * The following EDMA channels/slots are not being used by drivers (for
+ * example: Timer, GPIO, UART events etc) on da850/omap-l138 EVM/Hawkboard,
+ * hence they are being reserved for codecs on the DSP side.
+ */
+static const s16 da850_dma0_rsv_chans[][2] = {
+	/* (offset, number) */
+	{ 8,  6},
+	{24,  4},
+	{30,  2},
+	{-1, -1}
+};
+
+static const s16 da850_dma0_rsv_slots[][2] = {
+	/* (offset, number) */
+	{ 8,  6},
+	{24,  4},
+	{30, 50},
+	{-1, -1}
+};
+
+static const s16 da850_dma1_rsv_chans[][2] = {
+	/* (offset, number) */
+	{ 0, 28},
+	{30,  2},
+	{-1, -1}
+};
+
+static const s16 da850_dma1_rsv_slots[][2] = {
+	/* (offset, number) */
+	{ 0, 28},
+	{30, 90},
+	{-1, -1}
+};
+
+static struct edma_rsv_info da850_edma_cc0_rsv = {
+	.rsv_chans	= da850_dma0_rsv_chans,
+	.rsv_slots	= da850_dma0_rsv_slots,
+};
+
+static struct edma_rsv_info da850_edma_cc1_rsv = {
+	.rsv_chans	= da850_dma1_rsv_chans,
+	.rsv_slots	= da850_dma1_rsv_slots,
+};
+
+static struct edma_rsv_info *da850_edma_rsv[2] = {
+	&da850_edma_cc0_rsv,
+	&da850_edma_cc1_rsv,
+};
+
+#ifdef CONFIG_CPU_FREQ
+static __init int da850trik_init_cpufreq(void)
+{
+	switch (system_rev & 0xF) {
+	case 3:
+		da850_max_speed = 456000;
+		break;
+	case 2:
+		da850_max_speed = 408000;
+		break;
+	case 1:
+		da850_max_speed = 372000;
+		break;
+	}
+
+	return da850_register_cpufreq("pll0_sysclk3");
+}
+#else
+static __init int da850_evm_init_cpufreq(void) { return 0; }
+#endif
+
+
+
+static const short da850trik_mmcsd0_pins[] = {
+	DA850_MMCSD0_DAT_0, DA850_MMCSD0_DAT_1, DA850_MMCSD0_DAT_2,
+	DA850_MMCSD0_DAT_3, DA850_MMCSD0_CLK, DA850_MMCSD0_CMD,
+	DA850_TRIK_MMCSD_CD_REG,
+	-1
+};
+
+static int da850trik_mmc_get_cd(int index)
+{
+	return !gpio_get_value(DA850_TRIK_MMCSD_CD_PIN);
+}
+
+static struct davinci_mmc_config da850trik_mmc_config = {
+	.get_cd		= da850trik_mmc_get_cd,
+	.wires		= 4,
+	.max_freq	= 50000000,
+	.caps		= MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED | MMC_CAP_4_BIT_DATA,
+	.version	= MMC_CTLR_VERSION_2,
+};
+
+static __init void da850trik_mmc_init(void)
+{
+	int ret;
+
+	ret = davinci_cfg_reg_list(da850trik_mmcsd0_pins);
+	if (ret) {
+		pr_warning("%s: MMC/SD0 mux setup failed: %d\n",
+			__func__, ret);
+		return;
+	}
+
+	ret = gpio_request(DA850_TRIK_MMCSD_CD_PIN, "MMC CD");
+	if (ret < 0) {
+		pr_warning("%s: can not open GPIO %d\n",
+			__func__, DA850_TRIK_MMCSD_CD_PIN);
+		return;
+	}
+	gpio_direction_input(DA850_TRIK_MMCSD_CD_PIN);
+
+	ret = da8xx_register_mmcsd0(&da850trik_mmc_config);
+	if (ret) {
+		pr_warning("%s: MMC/SD0 registration failed: %d\n",
+			__func__, ret);
+		goto mmc_setup_mmcsd_fail;
+	}
+
+	return;
+
+mmc_setup_mmcsd_fail:
+	gpio_free(DA850_TRIK_MMCSD_CD_PIN);
+}
+
+static int trik_usb11_power_status = 1;
+static int trik_usb11_set_power(unsigned port, int on)
+{
+	trik_usb11_power_status = on;
+	return 0;
+}
+
+static int trik_usb11_get_power(unsigned port)
+{
+	return trik_usb11_power_status;
+}
+
+static int trik_usb11_get_oci(unsigned port)
+{
+	return 0;
+}
+
+static int trik_usb11_ocic_notify(da8xx_ocic_handler_t handler)
+{
+	return 0;
+}
+
+static struct da8xx_ohci_root_hub omapl138_trik_usb11_pdata = {
+	.set_power      = trik_usb11_set_power,
+	.get_power      = trik_usb11_get_power,
+	.get_oci        = trik_usb11_get_oci,
+	.ocic_notify    = trik_usb11_ocic_notify,
+	/* TPS2087 switch @ 5V */
+	.potpgt         = (3 + 1) / 2,  /* 3 ms max */
+};
+
+static irqreturn_t omapl138_trik_usb20_ocic_irq(int irq, void *dev_id)
+{
+	printk(KERN_ERR "%s: over-current situation detected\n", __func__);
+	return IRQ_HANDLED;
+}
+
+static __init void da850trik_usb_init(void)
+{
+	int ret, irq;
+	u32 cfgchip2;
+
+	ret = davinci_cfg_reg(DA850_TRIK_USB20_OC_REG);
+	if (ret) {
+		pr_warning("%s: USB 2.0 PinMux setup failed: %d\n",
+			__func__, ret);
+		return;
+	}
+
+	ret = gpio_request_one(DA850_TRIK_USB20_OC_PIN,
+			GPIOF_DIR_IN, "USB 2.0 overcurrent");
+	if (ret < 0) {
+		pr_err("%s: failed to request GPIO for USB 2.0 port "
+			"over-current indicator: %d\n", __func__, ret);
+		goto usb20_setup_oc_fail;
+	}
+
+	irq = gpio_to_irq(DA850_TRIK_USB20_OC_PIN);
+	ret = request_irq(irq, omapl138_trik_usb20_ocic_irq, IRQF_DISABLED |
+				    IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+				    "USB2.0 over-current indicator", NULL);
+	if (ret) {
+		printk(KERN_ERR "%s: could not request IRQ to watch "
+			       "over-current indicator changes\n", __func__);
+		gpio_free(DA850_TRIK_USB20_OC_PIN);
+		goto usb20_setup_oc_fail;
+	}
+
+	/*
+	 * Set up USB clock/mode in the CFGCHIP2 register.
+	 * FYI:  CFGCHIP2 is 0x0000ef00 initially.
+	 */
+	cfgchip2 = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP2_REG));
+
+	/* USB2.0 PHY reference clock is 24 MHz */
+	cfgchip2 &= ~CFGCHIP2_REFFREQ;
+	cfgchip2 |=  CFGCHIP2_REFFREQ_24MHZ;
+
+	/*
+	 * Select internal reference clock for USB 2.0 PHY
+	 * and use it as a clock source for USB 1.1 PHY
+	 * (this is the default setting anyway).
+	 */
+	cfgchip2 &= ~CFGCHIP2_USB1PHYCLKMUX;
+	cfgchip2 |=  CFGCHIP2_USB2PHYCLKMUX;
+
+	/*
+	 * We have to override VBUS/ID signals when MUSB is configured into the
+	 * host-only mode -- ID pin will float if no cable is connected, so the
+	 * controller won't be able to drive VBUS thinking that it's a B-device.
+	 * Otherwise, we want to use the OTG mode and enable VBUS comparators.
+	 */
+	cfgchip2 &= ~CFGCHIP2_OTGMODE;
+#ifdef	CONFIG_USB_MUSB_HOST
+	cfgchip2 |=  CFGCHIP2_FORCE_HOST_VBUS_LOW;
+#else
+	cfgchip2 |=  CFGCHIP2_SESENDEN | CFGCHIP2_VBDTCTEN;
+#endif
+	__raw_writel(cfgchip2, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP2_REG));
+
+	/*
+	 * TPS2065 switch @ 5V supplies 1 A (sustains 1.5 A),
+	 * with the power on to power good time of 3 ms.
+	 */
+	ret = da8xx_register_usb20(500, 20);
+	if (ret)
+		pr_warning("%s: USB 2.0 registration failed: %d\n",
+			   __func__, ret);
+
+usb20_setup_oc_fail:
+
+	ret = da8xx_register_usb11(&omapl138_trik_usb11_pdata);
+	if (ret)
+		pr_warning("%s: USB 1.1 registration failed: %d\n",
+			__func__, ret);
+
+	return;
+}
+
+static void da850_panel_power_ctrl(int val)
+{
+	/* lcd backlight */
+	gpio_set_value(DA850_TRIK_LCD_BL_PIN, val);
+}
+
+static int da850_lcd_hw_init(void)
+{
+	int status;
+
+	status = gpio_request(DA850_TRIK_LCD_BL_PIN, "lcd backlight");
+	if (status < 0)
+		return status;
+
+	gpio_direction_output(DA850_TRIK_LCD_BL_PIN, 0);
+
+	/* Switch off panel power and backlight */
+	da850_panel_power_ctrl(0);
+
+	/* Switch on panel power and backlight */
+	da850_panel_power_ctrl(1);
+
+	return 0;
+}
+
+static struct davinci_uart_config da850trik_uart_config __initdata = {
+	.enabled_uarts = 0x3,
+};
+
+static struct i2c_board_info __initdata da850_trik_i2c0_devices[] = {
+};
+
+static struct davinci_i2c_platform_data da850_trik_i2c0_pdata = {
+	.bus_freq	= 100,	/* kHz */
+	.bus_delay	= 0,	/* usec */
+};
+
+static struct i2c_board_info __initdata da850_trik_i2c1_devices[] = {
+	{
+		I2C_BOARD_INFO("tlv320aic3x", 0x18),
+	},
+	{
+		I2C_BOARD_INFO("mma7660fc", 0x4c),
+		.flags = I2C_CLIENT_WAKE,
+		.platform_data = &board_mma7660fc_pdata,
+	},
+};
+
+static struct davinci_i2c_platform_data da850_trik_i2c1_pdata = {
+	.bus_freq	= 100,	/* kHz */
+	.bus_delay	= 0,	/* usec */
+};
+
+static __init void da850trik_init(void)
+{
+	int ret, audio;
+
+	davinci_serial_init(&da850trik_uart_config);
+
+	ret = da850_register_edma(da850_edma_rsv);
+	if (ret)
+		pr_warning("%s: EDMA registration failed: %d\n",
+			__func__, ret);
+
+	/* audio codec reset pin */
+	audio = 0;
+	ret = davinci_cfg_reg(DA850_TRIK_AUDIO_RESET_REG);
+	if (!ret){
+		ret = gpio_request(DA850_TRIK_AUDIO_RESET_PIN, "audio codec reset");
+		if (ret >= 0){
+			gpio_direction_output(DA850_TRIK_AUDIO_RESET_PIN, 1);
+			audio = 1;
+		}else{
+			pr_warning("da850trik_init: audio codec reset pin request failed: %d\n",
+					ret);
+		}
+	}else{
+		pr_warning("da850trik_init: audio codec reset pin setup failed: %d\n",
+				ret);
+	}
+
+	archos_accel_init(&board_mma7660fc_pdata);
+
+	ret = davinci_cfg_reg_list(da850_i2c0_pins);
+	if (ret)
+		pr_warning("da850trik_init: i2c0 mux setup failed: %d\n",
+				ret);
+
+	ret = da8xx_register_i2c(0, &da850_trik_i2c0_pdata);
+	if (ret)
+		pr_warning("da850trik_init: i2c0 registration failed: %d\n",
+				ret);
+
+	i2c_register_board_info(1, da850_trik_i2c0_devices,
+			ARRAY_SIZE(da850_trik_i2c0_devices));
+
+	ret = davinci_cfg_reg_list(da850_i2c1_pins);
+	if (ret)
+		pr_warning("da850trik_init: i2c1 mux setup failed: %d\n",
+				ret);
+
+	ret = da8xx_register_i2c(1, &da850_trik_i2c1_pdata);
+	if (ret)
+		pr_warning("da850trik_init: i2c1 registration failed: %d\n",
+				ret);
+
+	i2c_register_board_info(2, da850_trik_i2c1_devices,
+			ARRAY_SIZE(da850_trik_i2c1_devices));
+
+
+	ret = da8xx_register_watchdog();
+	if (ret)
+		pr_warning("%s: watchdog registration failed: %d\n",
+			__func__, ret);
+
+	da850trik_mmc_init();
+	da850trik_usb_init();
+
+	if (audio){
+		ret = davinci_cfg_reg_list(da850_trik_mcasp_pins);
+		if (ret)
+			pr_warning("da850trik_init: mcasp mux setup failed: %d\n",
+				ret);
+
+		da8xx_register_mcasp(0, &da850_trik_snd_data);
+	}
+
+	ret = davinci_cfg_reg_list(da850_lcdcntl_pins);
+	if (ret)
+		pr_warning("da850trik_init: lcdcntl mux setup failed: %d\n",
+				ret);
+
+	/* Handle board specific muxing for LCD here */
+	ret = davinci_cfg_reg(DA850_TRIK_LCD_BL_REG);
+	if (ret)
+		pr_warning("da850trik_init: lcd backlight control pins mux setup failed: %d\n",
+				ret);
+
+	ret = da850_lcd_hw_init();
+	if (ret)
+		pr_warning("da850trik_init: lcd initialization failed: %d\n",
+				ret);
+
+	nhd_24_240320sf_ctxi_data.panel_power_ctrl = da850_panel_power_ctrl,
+	ret = da8xx_register_lcdc(&nhd_24_240320sf_ctxi_data);
+	if (ret)
+		pr_warning("da850trik_init: lcdc registration failed: %d\n",
+				ret);
+	ret = da8xx_register_rtc();
+	if (ret)
+		pr_warning("%s: rtc setup failed: %d\n",
+			__func__, ret);
+
+	ret = da850trik_init_cpufreq();
+	if (ret)
+		pr_warning("%s: cpufreq registration failed: %d\n",
+			__func__, ret);
+
+	ret = da8xx_register_cpuidle();
+	if (ret)
+		pr_warning("%s: cpuidle registration failed: %d\n",
+			__func__, ret);
+
+	ret = da850_register_pm(&da850_pm_device);
+	if (ret)
+		pr_warning("%s: suspend registration failed: %d\n",
+			__func__, ret);
+
+	trik_init_wl1271();
+	ret = da8xx_register_spi(0, da850trik_spi_info,
+				 ARRAY_SIZE(da850trik_spi_info));
+	if (ret)
+		pr_warning("%s: spi 0 registration failed: %d\n",
+			__func__, ret);
+
+	trik_gpio_add_device_buttons();
+}
+
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+static int __init da850trik_console_init(void)
+{
+	if (!machine_is_omapl138_trikboard())
+		return 0;
+
+	return add_preferred_console("ttyS", 1, "115200");
+}
+console_initcall(da850trik_console_init);
+#endif
+
+static void __init da850trik_map_io(void)
+{
+	da850_init();
+}
+
+MACHINE_START(OMAPL138_TRIKBOARD, "AM18x/OMAP-L138 Trikboard")
+	.atag_offset	= 0x100,
+	.map_io		= da850trik_map_io,
+	.init_irq	= cp_intc_init,
+	.timer		= &davinci_timer,
+	.init_machine	= da850trik_init,
+	.dma_zone_size	= SZ_128M,
+MACHINE_END
diff --git a/arch/arm/mach-davinci/include/mach/uncompress.h b/arch/arm/mach-davinci/include/mach/uncompress.h
index 9dc7cf9..c0a1747 100644
--- a/arch/arm/mach-davinci/include/mach/uncompress.h
+++ b/arch/arm/mach-davinci/include/mach/uncompress.h
@@ -96,6 +96,7 @@ static inline void __arch_decomp_setup(unsigned long arch_id)
 		DEBUG_LL_DA8XX(davinci_da850_evm,	2);
 		DEBUG_LL_DA8XX(mityomapl138,		1);
 		DEBUG_LL_DA8XX(omapl138_hawkboard,	2);
+		DEBUG_LL_DA8XX(omapl138_trikboard,	1);
 
 		/* TNETV107x boards */
 		DEBUG_LL_TNETV107X(tnetv107x,		1);
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index ccbe16f..934565f 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -379,6 +379,7 @@ dm355_leopard		MACH_DM355_LEOPARD	DM355_LEOPARD		2138
 ts219			MACH_TS219		TS219			2139
 pca100			MACH_PCA100		PCA100			2149
 davinci_da850_evm	MACH_DAVINCI_DA850_EVM	DAVINCI_DA850_EVM	2157
+omapl138_trikboard	MACH_OMAPL138_TRIKBOARD	OMAPL138_TRIKBOARD	2158
 at91sam9g10ek		MACH_AT91SAM9G10EK	AT91SAM9G10EK		2159
 omap_4430sdp		MACH_OMAP_4430SDP	OMAP_4430SDP		2160
 magx_zn5		MACH_MAGX_ZN5		MAGX_ZN5		2162
diff --git a/sound/soc/davinci/davinci-evm.c b/sound/soc/davinci/davinci-evm.c
index f78c3f0..10f3a61 100644
--- a/sound/soc/davinci/davinci-evm.c
+++ b/sound/soc/davinci/davinci-evm.c
@@ -54,7 +54,8 @@ static int evm_hw_params(struct snd_pcm_substream *substream,
 		sysclk = 12288000;
 
 	else if (machine_is_davinci_da830_evm() ||
-				machine_is_davinci_da850_evm())
+				machine_is_davinci_da850_evm() ||
+				machine_is_omapl138_trikboard())
 		sysclk = 24576000;
 
 	else
@@ -239,6 +240,18 @@ static struct snd_soc_dai_link da850_evm_dai = {
 	.ops = &evm_ops,
 };
 
+
+static struct snd_soc_dai_link da850_trik_dai = {
+	.name = "TLV320AIC3X",
+	.stream_name = "AIC3X",
+	.cpu_dai_name= "davinci-mcasp.0",
+	.codec_dai_name = "tlv320aic3x-hifi",
+	.codec_name = "tlv320aic3x-codec.2-0018",
+	.platform_name = "davinci-pcm-audio",
+	.init = evm_aic3x_init,
+	.ops = &evm_ops,
+};
+
 /* davinci dm6446 evm audio machine driver */
 static struct snd_soc_card dm6446_snd_soc_card_evm = {
 	.name = "DaVinci DM6446 EVM",
@@ -279,6 +292,12 @@ static struct snd_soc_card da850_snd_soc_card = {
 	.num_links = 1,
 };
 
+static struct snd_soc_card da850_snd_soc_card_trik = {
+	.name = "DA850/OMAP-L138 TRIK",
+	.dai_link = &da850_trik_dai,
+	.num_links = 1,
+};
+
 static struct platform_device *evm_snd_device;
 
 static int __init evm_init(void)
@@ -305,6 +324,9 @@ static int __init evm_init(void)
 	} else if (machine_is_davinci_da850_evm()) {
 		evm_snd_dev_data = &da850_snd_soc_card;
 		index = 0;
+	} else if (machine_is_omapl138_trikboard()) {
+		evm_snd_dev_data = &da850_snd_soc_card_trik;
+		index = 0;
 	} else
 		return -EINVAL;
 
-- 
1.7.10.4

